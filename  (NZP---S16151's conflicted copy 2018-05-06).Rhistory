quant.bhv <- apply(df1[,val.2.plot],2,quantile)
# Probability of control activities
(control.probs <- exp(coefs.bhv)/sum(exp(coefs.bhv)))
sum(control.probs)
# Which should be the same as
control.seq <- seq(1,25,3)
(coefs.bhv.test <- apply(df1[,control.seq],2,mean))
# Now do the same for Trmt 1
#seq.val1 <- seq(11,35,3)
plot.seq.Trmt1 <- seq(38,62,3)
coefs.time2 <- apply(df1[,28:36],2,mean) + apply(df1[,plot.seq.Trmt1],2,mean)
(per2.probs <- exp(coefs.time2)/sum(exp(coefs.time2)))
# Which should be the same as
control.seq1 <- seq(2,26,3)
(coefs.bhv.test <- apply(df1[,control.seq1],2,mean))
#seq.val2 <- seq(12,36,3)
plot.seq.Trmt2 <- seq(39,63,3)
coefs.time3 <- apply(df1[,28:36],2,mean) + apply(df1[,plot.seq.Trmt2],2,mean)
(per3.probs <- exp(coefs.time3)/sum(exp(coefs.time3)))
# Which should be the same as
control.seq <- seq(3,27,3)
(coefs.bhv.test <- apply(df1[,control.seq],2,mean))
# Look at the probabilities for each time period
colnames(y)
control.probs
per2.probs
per3.probs
# Probabilities should add up to 1
sum(control.probs)
sum(per2.probs)
sum(per3.probs)
# ***********************************************************************
# ***********************************************************************
df.test <- df1[,-1:-27]
testing1 <- df.test[,9] + df.test[,34]
testing2 <- df.test[,35]
testing3 <- df.test[,36]
test <- cbind(testing2,testing3)
test <- as.matrix(test)
library(MCMCvis)
par(mfrow=c(1,1))
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-3.0,3.0))
# Loop through all the behaviors, creating a graph for each
Trt1 <- seq(14,35,3)
Trt2 <- seq(15,36,3)
val.xlab
for (i in 2:length(Trt1)){
testing2 <- df.test[,Trt1[i]]
testing3 <- df.test[,Trt2[i]]
test <- cbind(testing2,testing3)
test <- as.matrix(test)
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-5,5),main=val.xlab[i])
}
head(Trt1)
head(df.test)
summary(df.test[12])
summary(df.test[11])
summary(df.test[10])
summary(df.test[13])
summary(df.test[14])
head(df.test)
# Load necessary libraries
library(tidyr)
library(R2jags)
library(MCMCvis)
# Set working directory
#setwd("C:/Users/stabachj/Dropbox (Smithsonian)/Projects/Oryx/StressAnalysis/Behavior")
#setwd("C:/Users/Jared/Dropbox (Smithsonian)/Projects/Oryx/StressAnalysis/Behavior")
# Read in file
bdata <- read.csv("Behavior.Nov3.csv")
# Fix the data/time fields
bdata$TimeStart <- as.POSIXct(strptime(paste0(bdata$Date," ",bdata$TimeStart), format="%m/%d/%Y %H:%M"))
bdata$TimeEnd <- as.POSIXct(strptime(paste0(bdata$Date," ",bdata$TimeEnd), format="%m/%d/%Y %H:%M"))
# Re-order dataframe so all the behavior data is at the end
bdata <- bdata[,c(1:15,26:27,16:25)]
# Code the Control and Treatment records.
bdata$Control <- ifelse(bdata$Treatment == "control",1,2)
bdata.control <- bdata[which(bdata$Treatment == "control"),]
bdata <- bdata[which(bdata$Treatment != "control"),]
# Look at data quickly
# Set AdjObTime as a factor
# Summarize Standing Head up (SHU)
bdata$AdjObTime <- as.factor(bdata$AdjObTime)
boxplot(pro.SHU~AdjObTime,data=bdata,boxwex=0.5,frame = FALSE,col=c("gray100","gray80","gray20"),main="Standing Head Up", xlab="Treatment Group", ylab="Percent of Activity")
# This does not account for repeated measures.
# Variables pro.walk and pro.oov both have NAs.
# Remove or the variable cannon be included in analysis.
bdata$RSums <- rowSums(bdata[18:26], na.rm=TRUE)
summary(bdata$RSums)
# Some of the rows are < 1.  Set columns to 0.
bdata$pro.walk[is.na(bdata$pro.walk)] <- 0
bdata$pro.oov[is.na(bdata$pro.oov)] <- 0
summary(bdata)
# ***************************************
# ***************************************
# Fit models in a Bayesian regression framework to estimate probabilities for each behavior
# ***************************************
# ***************************************
# Set-up burn-in/iterations for JAGS
n.iter=10000 # Number of iterations
n.update=n.iter*0.20 # burn-in iterations (0.20 percent)
n.adapt=1000 # adaptation iterations
# Set up blank list
data.list <- vector("list")
bdata$Animal <- droplevels(bdata$Animal)
n.groups <- length(unique(bdata$Animal))
# Calculate the differenc in time from 7 am each day
bdata$Time <- difftime(bdata$TimeStart, paste0(strptime(bdata$TimeStart, format = "%Y-%m-%d")," ","7:00:00"),units="mins")
Time <-as.numeric(scale(bdata$Time))
bdata$Time <- Time
data.list=list(
# There is both a TotalObs field and a ModTotObs field
#C = round(bdata$TotalObs*bdata$pro.SHU),
C = bdata$ModTotObs*bdata$pro.SHU,
#N = bdata$TotalObs,
N = bdata$ModTotObs,
ID = as.numeric(bdata$Animal),
PERIOD = bdata$AdjObTime,
n.groups = length(unique(bdata$Animal)),
n = length(bdata$Date),
TimePast = bdata$Time
)
# Setup initial values
inits=list(
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)), # Chain 1
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)), # Chain 2
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)) # Chain 3
)
# Fit model
jm2=jags.model("Binomial_GLMM.R",data=data.list,inits=inits,n.chains=length(inits),n.adapt=n.adapt)
update(jm2, n.iter=n.update) # Burn-in the chain
zm2=coda.samples(jm2,variable.names=c("alpha","beta1","beta2","beta3", "mu.int","sigma.int","Contrast1v2","Contrast1v3","Contrast2v3"), n.iter=n.iter, n.thin=1) # generate the coda object
#beta1 is the contrast with period 1 and 2
#beta2 is the contrast with period 1 and 3
#alphas are the random effects for each individual
# Deviance Information Criteria
zdic=dic.samples(jm2,n.iter=n.iter)
# Return DIC and deviaance
zdic
# Summarize object
print("*********************************************************************")
print(summary(zm2))
# Run convergence diagnostics
gelman.diag(zm2, multivariate=FALSE)
# Okay, values are 1.
# Need to create the dataframes from the code objects
# Plot the histograms and trace plots to examine and make sure that the parameter space has been explored
df1 = as.data.frame(rbind(zm2[[1]]))
df2 = as.data.frame(rbind(zm2[[2]]))
df3 = as.data.frame(rbind(zm2[[3]]))
# Remove the burn-in period
df1 <- df1[(n.update+1):n.iter,]
df2 <- df2[(n.update+1):n.iter,]
df3 <- df3[(n.update+1):n.iter,]
# Setup variables to plot and plotting window
Val.2.Plot <- c(16,1,2,3)
val.xlab <- c("Intercept","Beta 1","Beta 2","Beta 3")
val.header <- c("Intercept","Contrast - 1v2","Contrast - 1v3","Contrast - 2v3")
par(mfrow=c(length(Val.2.Plot),2))
for (i in 1:length(Val.2.Plot)){
# Plot histogram, eliminating burn-in
hist(df1[,Val.2.Plot[i]], freq=FALSE, breaks=100, xlim=c(min(df1[,Val.2.Plot[i]]),max(df1[,Val.2.Plot[i]])), main= paste0("Posterior Distribution of ",val.header[i]), xlab=val.xlab[i])
# Overlay posterior distribution
lines(density(df1[,Val.2.Plot[i]],adjust=3),col="black",lwd=2)
lines(density(df2[,Val.2.Plot[i]],adjust=3),col="red",lwd=2)
lines(density(df3[,Val.2.Plot[i]],adjust=3),col="blue",lwd=2)
# Plot trace plot
plot(df1[,Val.2.Plot[i]],xlab="Iteration Number",ylab=paste0("Value of "," ",val.header[i]),type="l", main="Trace Plot")
lines(df2[,Val.2.Plot[i]],col="red")
lines(df3[,Val.2.Plot[i]],col="blue")
abline(a=mean(df1[,Val.2.Plot[i]]),b=0,col="green")
}
# **********************************************************
# **********************************************************
# Now loop through and run for all behaviors
# Create a null list to store the results
mod.summary <- list()
gelman.list <- list()
result.list <- list()
# This ends up being a big process....but am just looping over each of the columns and creating individual models
# I then append the results to a list
for(i in c(18:26)){
print(paste0("Working On Variable: ",names(bdata[i])))
name.Val <- names(bdata[i])
data.list=list(
#C = round(bdata$TotalObs*bdata[,i]),
#N = bdata$TotalObs,
C = bdata$ModTotObs*bdata[,i],
N = bdata$ModTotObs,
ID = as.numeric(bdata$Animal),
PERIOD = bdata$AdjObTime,
n.groups = length(unique(bdata$Animal)),
n = length(bdata$Date),
TimePast = bdata$Time
)
# Setup initial values
inits=list(
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)), # Chain 1
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)), # Chain 2
list(alpha=rnorm(n.groups,0,2),beta1=rnorm(1,0,1),beta2=rnorm(1,0,1),beta3=rnorm(1,0,1),mu.int=rnorm(1,0,1)) # Chain 3
)
# Fit model
jm2=jags.model("Binomial_GLMM.R",data=data.list,inits=inits,n.chains=length(inits),n.adapt=n.adapt)
update(jm2, n.iter=n.update) # Burn-in the chain
zm2=coda.samples(jm2,variable.names=c("alpha","beta1","beta2","beta3","mu.int","sigma.int","Contrast1v2","Contrast1v3","Contrast2v3"), n.iter=n.iter, n.thin=1) # generate the coda object
# Deviance Information Criteria
zdic=dic.samples(jm2,n.iter=n.iter)
# Return DIC and deviaance
zdic
# Summarize object and put in a list
mod.summary[[i-17]] <- summary(zm2)
names(mod.summary)[i-17] <- name.Val
# Run convergence diagnostics
gelman.list[[i-17]] <- gelman.diag(zm2, multivariate=FALSE)
names(gelman.list)[i-17] <- name.Val
# create dataframes from coda objects
# Plot the histograms and trace plots to examine and make sure that the parameter space has been explored
df1 = as.data.frame(rbind(zm2[[1]]))
df2 = as.data.frame(rbind(zm2[[2]]))
df3 = as.data.frame(rbind(zm2[[3]]))
# Remove the burn-in period
df1 <- df1[(n.update+1):n.iter,]
df2 <- df2[(n.update+1):n.iter,]
df3 <- df3[(n.update+1):n.iter,]
# Setup variables to plot and plotting window
Val.2.Plot <- c(16,1,2,3)
val.xlab <- c("Intercept","Beta 1","Beta 2","Beta 3")
val.header <- c("Intercept","Contrast - 1v2","Contrast - 1v3","Contrast - 2v3")
# Print the trace plots
for (j in 1:length(Val.2.Plot)){
# Plot histogram, eliminating burn-in
hist(df1[,Val.2.Plot[j]], freq=FALSE, breaks=100, xlim=c(min(df1[,Val.2.Plot[j]]),max(df1[,Val.2.Plot[j]])), main= paste0("Posterior Distribution of ",val.header[j]), xlab=val.xlab[j])
# Overlay posterior distribution
lines(density(df1[,Val.2.Plot[j]],adjust=3),col="black",lwd=2)
lines(density(df2[,Val.2.Plot[j]],adjust=3),col="red",lwd=2)
lines(density(df3[,Val.2.Plot[j]],adjust=3),col="blue",lwd=2)
# Plot trace plot
plot(df1[,Val.2.Plot[j]],xlab="Iteration Number",ylab=paste0("Value of "," ",val.header[j]),type="l", main="Trace Plot")
lines(df2[,Val.2.Plot[j]],col="red")
lines(df3[,Val.2.Plot[j]],col="blue")
abline(a=mean(df1[,Val.2.Plot[j]]),b=0,col="green")
}
# Bind together in a list...naming the lists..to plot/summarize
df1 <- rbind(df1,df2,df3)
result.list[[i-17]] <- df1
names(result.list)[i-17] <- name.Val
}
# **********************************************************
# **********************************************************
# Look at results
# **********************************************************
# **********************************************************
head(result.list$pro.SHU)
str(result.list)
# Look at convergence....all look good
gelman.list
# Can also look at the model summaries
mod.summary
# Using the MCMCvis package to graph results
# Remove all of the columns except the first through contrast evaluations
# Then bind together in a dataframe
test <- lapply(result.list, function(x){x[,1:3]})
test.names <- names(test)
test <- do.call(cbind.data.frame, test)
# Convert to a matrix and plot
test <- as.matrix(test)
# Setting this up to label the plot
t1 <- rep(test.names,each=3)
t2 <- rep(c("- 1v2","- 1v3","- 2v3"),times=length(test.names))
t3 <- sprintf(paste0(t1,t2))
par(mfrow=c(1,1))
MCMCplot(test, labels=c(t3), xlim=c(-5,5))
# ****************************************
# ****************************************
result.list
head(mod.summary)
str(result.list)
test <- lapply(result.list, function(x){x[,1:3]})
str(test)
test.names <- names(test)
test.names
test <- do.call(cbind.data.frame, test)
head(test)
test <- as.matrix(test)
head(test)
t1 <- rep(test.names,each=3)
t1
t2 <- rep(c("- 1v2","- 1v3","- 2v3"),times=length(test.names))
t2
t3 <- sprintf(paste0(t1,t2))
t3
par(mfrow=c(1,1))
MCMCplot(test, labels=c(t3), xlim=c(-5,5))
head(test)
head(df.test)
ncol(df.test)
trt1.seq <- seq(11,35,3)
df.trmt1 <- df.test[,df.test[trt1.seq]]
trt1.seq
df.trmt1 <- df.test[,df.test[,trt1.seq]]
df.trmt1 <- df.test[,df.test[11]]
df.trmt1 <- df.test[,trt1.seq]
head(df.trmt1)
MCMCplot(df.trmt1)
head(df.trmt1)
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-3.0,3.0))
df.test <- df1[,-1:-27]
testing1 <- df.test[,9] + df.test[,34]
testing2 <- df.test[,35]
testing3 <- df.test[,36]
test <- cbind(testing2,testing3)
test <- as.matrix(test)
library(MCMCvis)
par(mfrow=c(1,1))
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-3.0,3.0))
head(test)
trt1.seq <- seq(11,35,3)
df.trmt1 <- df.test[,trt1.seq]
head(df.trmt1)
df.trmt1 <- df.test[,trt1.seq]
head(df.test)
head(df.test)
df.test <- df1[,-1:-27]
head(df.test)
#*********************************************************************************************************
#*********************************************************************************************************
# Project: SHO Stress and Behavior Analysis
# Date: 10 November 2016
# Author: Stephanie Cunningham, Jared Stabach, Grant Connette
# Description: Summarize/investigate behavioral changes in Scimitar-horned oryx fit with GPS collars
#               Fit data in a Bayesian framework to estimate the probability of each behavioral activity
#               Data fit based on a multinomial likelihood
#               How does each behavior change across the time periods?  Using each animal as a control.
#               Expectation is that adverse behaviors, such as head-shaking, should increase during the period animals are collared and then return to normal.
#*********************************************************************************************************
#*********************************************************************************************************
# Clear the cache
rm(list=ls())
# Load necessary libraries
library(tidyr)
# Set working directory...already set in RStudi
#setwd("C:/Users/Jared/Dropbox (Smithsonian)/Projects/Oryx/StressAnalysis/Behavior")
# Read in file
bdata <- read.csv("Behavior.Nov3.csv")
# Fix the data/time fields
bdata$TimeStart <- as.POSIXct(strptime(paste0(bdata$Date," ",bdata$TimeStart), format="%m/%d/%Y %H:%M"))
bdata$TimeEnd <- as.POSIXct(strptime(paste0(bdata$Date," ",bdata$TimeEnd), format="%m/%d/%Y %H:%M"))
# Re-order dataframe so all the behavior data is at the end
bdata <- bdata[,c(1:15,26:27,16:25)]
# Code the Control and Treatment records.
bdata$Control <- ifelse(bdata$Treatment == "control",1,2)
bdata.control <- bdata[which(bdata$Treatment == "control"),]
bdata <- bdata[which(bdata$Treatment != "control"),]
# Look at data quickly
# Set AdjObTime as a factor
# Summarize Standing Head up (SHU)
bdata$AdjObTime <- as.factor(bdata$AdjObTime)
boxplot(pro.SHU~AdjObTime,data=bdata,boxwex=0.5,frame = FALSE,col=c("gray100","gray80","gray20"),main="Standing Head Up", xlab="Treatment Group", ylab="Percent of Activity")
# This does not account for repeated measures.
# Variables pro.walk and pro.oov both have NAs.
# Remove or the variable cannon be included in analysis.
bdata$RSums <- rowSums(bdata[18:26], na.rm=TRUE)
summary(bdata$RSums)
# Some of the rows are < 1.  Set columns to 0.
bdata$pro.walk[is.na(bdata$pro.walk)] <- 0
bdata$pro.oov[is.na(bdata$pro.oov)] <- 0
summary(bdata)
# ***********************************************************************
# ***********************************************************************
# Load library
library(R2jags)
# Set-up burn-in/iterations for JAGS
n.iter=10000 # Number of iterations
n.update=n.iter*0.20 # burn-in iterations (0.20 percent)
n.adapt=1000 # adaptation iterations
# Set up blank list
data.list <- vector("list")
# Reformat data and bind together
SHU <- as.integer(bdata$ModTotObs*bdata$pro.SHU)
SHD <- as.integer(bdata$ModTotObs*bdata$pro.SHD)
lay <- as.integer(bdata$ModTotObs*bdata$pro.lay)
HDSK <- as.integer(bdata$ModTotObs*bdata$pro.headshake)
WALK <- as.integer(bdata$ModTotObs*bdata$pro.walk)
FHU <- as.integer(bdata$ModTotObs*bdata$pro.FHU)
FHD <- as.integer(bdata$ModTotObs*bdata$pro.FHD)
SCRATCH <- as.integer(bdata$ModTotObs*bdata$pro.scratch)
SOCIAL <- as.integer(bdata$ModTotObs*bdata$pro.social)
y <- cbind(SHU,SHD,lay,HDSK,WALK,FHU,FHD,SCRATCH,SOCIAL)
class(y)
# Setup the data list
data.list=list(
Y = y,
n.outcomes = ncol(y),
#ID = as.numeric(bdata$Animal),
PERIOD = bdata$AdjObTime,
N = apply(y,1,sum),
#n.groups = length(unique(bdata$Animal)),
n = nrow(y)
)
# Fit model
jm2=jags.model("Multinomial.R",data=data.list,n.chains=3,n.adapt=n.adapt)
update(jm2, n.iter=n.update) # Burn-in the chain
zm2=coda.samples(jm2,variable.names=c("alpha","beta","PROBS"), n.iter=n.iter, n.thin=1)
# generate the coda object
# Deviance Information Criteria
zdic=dic.samples(jm2,n.iter=n.iter)
zdic
# Summarize object
print("*********************************************************************")
print(summary(zm2))
# Run convergence diagnostics
gelman.diag(zm2, multivariate=FALSE)
# Need to create the dataframes from the code objects
# Plot the histograms and trace plots to examine and make sure that the parameter space has been explored
df1 = as.data.frame(rbind(zm2[[1]]))
df2 = as.data.frame(rbind(zm2[[2]]))
df3 = as.data.frame(rbind(zm2[[3]]))
# Remove the burn-in period
df1 <- df1[(n.update+1):n.iter,]
df2 <- df2[(n.update+1):n.iter,]
df3 <- df3[(n.update+1):n.iter,]
# Setup variables to plot and plotting window
val.xlab <- colnames(y)
# Look at the trace plots for all the posterior distributions for the behaviors
par(mfrow=c(3,2))
# Plot the control probabilities for each behavior to investigate proper exploration of the parameter space
val.2.plot <- 28:36
#plot.seq <- seq(1,25,3)
plot.seq.Trmt1 <- seq(2,26,3)
plot.seq.Trmt2 <- seq(3,27,3)
for (i in 2:length(val.xlab)){
# Plot histogram, eliminating burn-in
#print(i)
hist(df1[,val.2.plot[i]], freq=FALSE, breaks=100, xlim=c(min(df1[,val.2.plot[i]]),max(df1[,val.2.plot[i]])), main= paste0("Posterior Distribution of ",val.xlab[i]), xlab=val.xlab[i])
# Overlay posterior distribution
lines(density(df1[,val.2.plot[i]],adjust=3),col="black",lwd=2)
lines(density(df2[,val.2.plot[i]],adjust=3),col="red",lwd=2)
lines(density(df3[,val.2.plot[i]],adjust=3),col="blue",lwd=2)
# Plot trace plot
plot(df1[,val.2.plot[i]],xlab="Iteration Number",ylab=paste0("Value of "," ",val.xlab[i]),type="l", main="Trace Plot")
lines(df2[,val.2.plot[i]],col="red")
lines(df3[,val.2.plot[i]],col="blue")
abline(a=mean(df1[,val.2.plot[i]]),b=0,col="green")
}
# Summarize the activity probabilities....am just using chain 1 here (df1)
# plot.seq... are indexes to calculate the probability summaries for each of the treatment groups, including the control.
# The summed probabilities should all sum to 1 across each activity
# This was the whole reason for going to moving to a multinomial regression
coefs.bhv <- apply(df1[,val.2.plot],2,mean)
quant.bhv <- apply(df1[,val.2.plot],2,quantile)
# Probability of control activities
(control.probs <- exp(coefs.bhv)/sum(exp(coefs.bhv)))
sum(control.probs)
# Which should be the same as
control.seq <- seq(1,25,3)
(coefs.bhv.test <- apply(df1[,control.seq],2,mean))
# Now do the same for Trmt 1
#seq.val1 <- seq(11,35,3)
plot.seq.Trmt1 <- seq(38,62,3)
coefs.time2 <- apply(df1[,28:36],2,mean) + apply(df1[,plot.seq.Trmt1],2,mean)
(per2.probs <- exp(coefs.time2)/sum(exp(coefs.time2)))
# Which should be the same as
control.seq1 <- seq(2,26,3)
(coefs.bhv.test <- apply(df1[,control.seq1],2,mean))
#seq.val2 <- seq(12,36,3)
plot.seq.Trmt2 <- seq(39,63,3)
coefs.time3 <- apply(df1[,28:36],2,mean) + apply(df1[,plot.seq.Trmt2],2,mean)
(per3.probs <- exp(coefs.time3)/sum(exp(coefs.time3)))
# Which should be the same as
control.seq <- seq(3,27,3)
(coefs.bhv.test <- apply(df1[,control.seq],2,mean))
# Look at the probabilities for each time period
colnames(y)
control.probs
per2.probs
per3.probs
# Probabilities should add up to 1
sum(control.probs)
sum(per2.probs)
sum(per3.probs)
# ***********************************************************************
# ***********************************************************************
df.test <- df1[,-1:-27]
testing1 <- df.test[,9] + df.test[,34]
testing2 <- df.test[,35]
testing3 <- df.test[,36]
test <- cbind(testing2,testing3)
test <- as.matrix(test)
library(MCMCvis)
par(mfrow=c(1,1))
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-3.0,3.0))
# Loop through all the behaviors, creating a graph for each
Trt1 <- seq(14,35,3)
Trt2 <- seq(15,36,3)
val.xlab
for (i in 2:length(Trt1)){
testing2 <- df.test[,Trt1[i]]
testing3 <- df.test[,Trt2[i]]
test <- cbind(testing2,testing3)
test <- as.matrix(test)
MCMCplot(test, labels=c("Treatment1","Treatment2"),xlim=c(-5,5),main=val.xlab[i])
}
# Show all the contrast in Time period 1 (Trmt1)
df.trmt1 <- df.test[,Trt1]
MCMCplot(df.trmt1)
head(dr.test)
head(dt.test)
head(df.test)
head(df.trmt2)
df.trmt2 <- df.test[,Trt2]
head(df.trmt2)
MCMCplot(df.trmt2)
